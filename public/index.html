<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Ping-Pong Online</title>
  </head>
  <body>
    <script src="/socket.io/socket.io.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.js"></script>
<script>
$(function(){
  var GAME_SETTINGS = null;
  var INTERVAL = 10;

  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext("2d");
  $(canvas).css("display", "block");
  $(canvas).css("border", "black 1px solid");
  $(canvas).css("margin", "0 auto");

  var socket = io();

  socket.on('connected', function(SERVER_GAME_SETTINGS){
    GAME_SETTINGS = SERVER_GAME_SETTINGS;
    $(canvas).attr("width", GAME_SETTINGS.WIDTH);
    $(canvas).attr("height", GAME_SETTINGS.HEIGHT);
    document.body.appendChild(canvas);
    start.initialize();
  });

  socket.on('in', function(){
    clearInterval(waiting.interval);
    $('body').on('keydown', function(e){
      e.preventDefault();
      socket.emit('keydown', e.keyCode);
    });
    $('body').on('keyup', function(e){
      e.preventDefault();
      socket.emit('keyup', e.keyCode);
    });
    $('canvas').on('mousemove', function(e){
      e.preventDefault();
      socket.emit('mousemove', e.offsetX, e.offsetY);
    });
    $('canvas').on('click', function(e){
      e.preventDefault();
      socket.emit('click', e.offsetX, e.offsetY);
    });
  });

  socket.on('update', function(statuses){
    if(GAME_SETTINGS == null) return;
    drawBackground();
    drawNet();
    drawBorder();
    statuses.forEach(function(status){
      switch(status.shape){
        case "rectangle":
          ctx.fillStyle = status.color;
          ctx.fillRect(status.x,status.y,status.width,status.height);
          break;
        case "circle":
          ctx.fillStyle = status.color;
          ctx.beginPath();
          ctx.arc(status.x,status.y,status.r,0,2*Math.PI);
          ctx.stroke();
          ctx.fill();
          break;
        case "text":
          ctx.font = status.size+"px "+status.font;
          ctx.fillStyle = status.color;
          ctx.textAlign = status.textAlign;
          ctx.fillText(status.text,status.x,status.y);
          break;
      }
    });
  });

  socket.on('destroy', function(){
    opponentLeft.initialize();
    $('body').off();
  });

  function drawBackground(globalAlpha,color){
    ctx.save();
    ctx.globalAlpha = globalAlpha?globalAlpha:1;
    ctx.fillStyle = color?color:GAME_SETTINGS.BACKGROUND_COLOR;
    ctx.fillRect(0,0,GAME_SETTINGS.WIDTH,GAME_SETTINGS.HEIGHT);
    ctx.restore();
  }

  function drawBorder(){
    ctx.fillStyle = "#000000";
    ctx.fillRect(0,0,GAME_SETTINGS.WIDTH,GAME_SETTINGS.BORDER_WIDTH);
    ctx.fillRect(0,GAME_SETTINGS.HEIGHT-GAME_SETTINGS.BORDER_WIDTH,GAME_SETTINGS.WIDTH,GAME_SETTINGS.BORDER_WIDTH);
  }

  function drawNet(){
    var num = 10;
    var height = GAME_SETTINGS.HEIGHT/((num+1)*2);
    var y = height/2;
    var x = (GAME_SETTINGS.WIDTH-GAME_SETTINGS.NET.WIDTH)/2;
    ctx.fillStyle = "#000000";
    while(y < GAME_SETTINGS.HEIGHT){
        ctx.fillRect(x,y,GAME_SETTINGS.NET.WIDTH,height);
        y += height*2;
    }
  }

  var start = new (function(){
    var start = this;
    start.interval = null;

    start.button1 = new ButtonObject();
    start.button1.setEvents = function(){
      $(canvas).on("click",this.click);
      $(canvas).on("mousemove",this.mousemove);
    };
    start.button1.click = function(e){
      var rect = start.button1.data.rect;
      if(pointSquareCollusionCheck(e.offsetX, e.offsetY, rect)){
        start.toWaiting();
      }
    };
    start.button1.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      animation.count += animation.dir;
      if(animation.count <= 0 || animation.count >= animation.maxCount ){
        animation.dir *= -1;
      }
      text.color.current.transparency = 0.2 + 0.7*(animation.count/100);
    };
    start.button1.mousemove = function(e){
      var rect = start.button1.data.rect;
      var text = start.button1.data.text;
      var mouseover = pointSquareCollusionCheck(e.offsetX, e.offsetY, rect);

      rect.color.current.fill   = mouseover?rect.color.fill.mouseover  :rect.color.fill.default;
      rect.color.current.stroke = mouseover?rect.color.stroke.mouseover:rect.color.stroke.default;
      text.color.current.fill   = mouseover?text.color.fill.mouseover  :text.color.fill.default;
    };

    start.initialize = function(){
      start.button1.initialize(canvas,ctx,GAME_SETTINGS,{
        rect: {
          x: undefined,
          y: undefined,
          width: 230,
          height: 50,
          lineWidth: 2,
          color: {current:{fill: undefined, stroke: undefined}, fill:{default: "#1099cc", mouseover: "#0686e0"},stroke:{default: "#223344", mouseover: "#223344"}}
        },
        text:{
          x: undefined,
          y: undefined,
          size: 30,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "START GAME",
          color: {current:{fill: undefined, stroke: undefined}, fill:{default: "#123456", mouseover: "#ddeeff"}}
        },
        animation: {
          maxCount: 100,
          count: 0,
          dir: 1,
        }
      });
      start.interval = setInterval(start.loop,INTERVAL)
    };
    start.loop = function(){
      start.button1.update();
      drawBackground();
      start.button1.draw();
    };
    start.destroy = function(){
      $(canvas).off();
      clearInterval(start.interval);
    };
    start.toWaiting = function(){
      start.destroy();
      socket.emit('waiting');
      waiting.initialize();
    };
  })();

  var waiting = new (function(){
    var waiting = this;
    waiting.interval = null;

    waiting.text1 = new TextObject();
    waiting.text1.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      animation.count += animation.dir;
      if(animation.count <= 0 || animation.count >= animation.maxCount ){
        animation.dir *= -1;
      }
      text.color.current.transparency = 0.2 + 0.7*(animation.count/100);
    };

    waiting.initialize = function(){
      waiting.text1.initialize(canvas,ctx,GAME_SETTINGS,{
        text:{
          x: undefined,
          y: undefined,
          size: 30,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "WAITING FOR OPPONENT..",
          color: {current:{fill: undefined, stroke: undefined, transparency: undefined}, fill:{default: "#000000"}}
        },
        animation: {
          maxCount: 100,
          count: 0,
          dir: 1,
        }
      });
      waiting.interval = setInterval(waiting.loop,INTERVAL)
    };
    waiting.loop = function(){
      waiting.text1.update();
      drawBackground();
      waiting.text1.draw();
    };
    waiting.destroy = function(){
      clearInterval(waiting.interval);
    };
  })();

  var opponentLeft = new (function(){
    var opponentLeft = this;
    opponentLeft.interval = null;
    opponentLeft.text1 = new TextObject();
    opponentLeft.text1.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      animation.count++;
      text.color.current.transparency = 0.2 + 0.7*(animation.count/100);
    };
    opponentLeft.text2 = new TextObject();
    opponentLeft.text2.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      if(animation.count == 0) text.color.current.fill = undefined;
      animation.count++;
      if(animation.count == 101) text.color.current.fill = text.color.fill.default;
      if(animation.count > 100) text.color.current.transparency = ((animation.count-100)/150);
    };

    opponentLeft.initialize = function(){
      opponentLeft.count =0;
      opponentLeft.text1.initialize(canvas,ctx,GAME_SETTINGS,{
        text:{
          x: undefined,
          y: GAME_SETTINGS.HEIGHT/2-20,
          size: 32,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "OPPONENT LEFT!",
          color: {current:{fill: undefined, stroke: undefined, transparency: undefined}, fill:{default: "#000000"}}
        },
        animation: {
          maxCount: 200,
          count: 0,
        }
      });
      opponentLeft.text2.initialize(canvas,ctx,GAME_SETTINGS,{
        text:{
          x: undefined,
          y: GAME_SETTINGS.HEIGHT/2+20,
          size: 25,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "GOING BACK TO START..",
          color: {current:{fill: undefined, stroke: undefined, transparency: undefined}, fill:{default: "#000000"}}
        },
        animation: {
          count: 0,
        }
      });
      opponentLeft.interval = setInterval(opponentLeft.loop,INTERVAL)
    };
    opponentLeft.loop = function(){
      opponentLeft.text1.update();
      opponentLeft.text2.update();
      opponentLeft.update();
      opponentLeft.draw();
      opponentLeft.text1.draw();
      opponentLeft.text2.draw();
    };
    opponentLeft.count = undefined;
    opponentLeft.imgData = undefined;
    opponentLeft.update = function(){
      if(opponentLeft.count == 0){
        drawBackground(0.8);
        opponentLeft.imgData=ctx.getImageData(0,0,GAME_SETTINGS.WIDTH,GAME_SETTINGS.HEIGHT);
      }
      opponentLeft.count++
      if(opponentLeft.count >= 300){
        opponentLeft.destroy();
        start.initialize();
      }
    }
    opponentLeft.draw = function(){
      ctx.putImageData(opponentLeft.imgData,0,0);
    }
    opponentLeft.destroy = function(){
      clearInterval(opponentLeft.interval);
    };
  })();
})

// Objects
function TextObject(){}

TextObject.prototype.initialize = function(canvas,ctx,GAME_SETTINGS,data){
  this.canvas = canvas;
  this.ctx = ctx;
  this.GAME_SETTINGS = GAME_SETTINGS;
  this.data = data;
  if(this.setEvents) this.setEvents();

  var text = this.data.text;
  var animation = data.animation;
  text.x = text.x?text.x:GAME_SETTINGS.WIDTH/2;
  text.y = text.y?text.y:GAME_SETTINGS.HEIGHT/2;
  text.color.current.fill = text.color.fill?text.color.fill.default:null;
  text.color.current.stroke = text.color.stroke?text.color.stroke.default:null;
};

TextObject.prototype.draw = function(){
  var ctx = this.ctx;
  ctx.save();
  ctx.beginPath();

  var text = this.data.text;
  ctx.font = text.size+"px "+text.font;
  ctx.textAlign = text.textAlign;
  ctx.textBaseline = text.textBaseline;
  ctx.globalAlpha = text.color.current.transparency?text.color.current.transparency:1;
  if(text.color.current.fill){
    ctx.fillStyle = text.color.current.fill;
    ctx.fillText(text.message, text.x, text.y);
  }
  if(text.color.current.stroke){
    ctx.strokeStyle = text.color.current.stroke;
    ctx.lineWidth = text.lineWidth;
    ctx.strokeText(text.message, text.x, text.y);
  }

  ctx.restore();
};

function ButtonObject(){
  TextObject.call(this);
};
ButtonObject.prototype = new TextObject();
ButtonObject.prototype.constructor = ButtonObject;

ButtonObject.prototype.initialize = function(canvas,ctx,GAME_SETTINGS,data){
  TextObject.prototype.initialize.call(this,canvas,ctx,GAME_SETTINGS,data);
  var rect = this.data.rect;
  rect.x = rect.x?rect.x:(GAME_SETTINGS.WIDTH - rect.width)/2;
  rect.y = rect.y?rect.y:(GAME_SETTINGS.HEIGHT - rect.height)/2;
  rect.color.current.fill = rect.color.fill?rect.color.fill.default:null;
  rect.color.current.stroke = rect.color.stroke?rect.color.stroke.default:null;

};

ButtonObject.prototype.draw = function(){
  var ctx = this.ctx;
  ctx.save();
  ctx.beginPath();

  var rect = this.data.rect;
  ctx.globalAlpha = rect.color.current.transparency?text.color.current.transparency:1;
  if(rect.color.current.fill){
    ctx.fillStyle = rect.color.current.fill;
    ctx.fillRect(rect.x,rect.y,rect.width,rect.height);
  }
  if(rect.color.current.stroke){
    ctx.strokeStyle = rect.color.current.stroke;
    ctx.lineWidth = rect.lineWidth;
    ctx.rect(rect.x,rect.y,rect.width,rect.height);
    ctx.stroke();
  }
  ctx.restore();
  TextObject.prototype.draw.call(this);
};

//Common Functions
function pointSquareCollusionCheck(x,y,square){
  if(x >= square.x && x <= square.x + square.width && y >= square.y && y <= square.y + square.height )
    return true;
}

</script>
  </body>
</html>
